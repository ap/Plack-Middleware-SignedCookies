use strict; no warnings;

use Plack::Test;
use Test::More tests => 17;
use HTTP::Cookies ();
use HTTP::Request::Common;
use Plack::Middleware::SignedCookies ();

sub mkck { my $kv = join '=', splice @_, 0, 2; join ';', $kv, @_ }

my ( $_s, $_h );

my $mw = Plack::Middleware::SignedCookies->new( app => sub {
	my @h = map +( 'Set-Cookie', $_ ), (
		mkck( 'cb', 'lorem "ipsum"' ),
		mkck( 'cx', 'dolor sit amet', ('secure') x !!$_s, ('httponly') x !!$_h ),
	);
	[ 200, \@h, [ join ';', sort split / *; */, $_[0]{'HTTP_COOKIE'}, -1 ] ];
} );

test_psgi app => $mw->to_app, client => sub {
	my ( $cb, $jar, $res, $all, $hto, $sec ) = ( shift, HTTP::Cookies->new );
	my $get = sub {
		my $req = $jar->add_cookie_header( GET 'http://127.0.0.1/' );
		$jar->extract_cookies( $res = $cb->( $req ) );
		$_ = [] for $all, $hto, $sec;
		$jar->scan( sub {
			push @$all, $_[1];
			push @$sec, $_[1] if $_[7];
			push @$hto, $_[1] if grep 'httponly' eq lc, keys %{ $_[-1] };
		} );
		$_ = join '!', sort @$_ for $all, $hto, $sec;
		$res->content;
	};

	is length, 17, 'Secret has been autogenerated: ' . sprintf '\\x%02X' x length, unpack 'C*' for $mw->secret;
	is $mw->httponly, 1, 'HttpOnly default has been set';

	$jar->set_cookie( 0, ( cb => 1 ), '/', '127.0.0.1' );
	is $get->(), '', 'Unknown cookies ignored in initial request';

	is $all, 'cb!cx', 'Initial response includes exactly the expected cookies';
	is $hto, 'cb!cx', '... with default HttpOnly flag';
	is $sec, '',      '... and default secure flag';

	is $get->(), 'cb=lorem "ipsum";cx=dolor sit amet', 'Own cookies are recognized';

	$jar->set_cookie( 0, ( cx => 'nonsense' ), '/', '127.0.0.1' );
	is $get->(), 'cb=lorem "ipsum"', 'Tampered cookies are rejected';

	$mw->secure( 1 );
	$get->();
	is $sec, 'cb!cx', 'Setting the secure flag works';
	is $hto, 'cb!cx', '... with default HttpOnly flag included';

	$_s = 1;
	$get->();
	is $sec, 'cb!cx', '... even when it was already set';
	$_s = 0;

	$mw->httponly( 0 );
	$get->();
	is $hto, '',      'Disabling the HttpOnly flag works';
	is $sec, 'cb!cx', '... with the secure flag still set';

	$_h = 1;
	$get->();
	is $hto, 'cx', '... and it respects a pre-existing flag';
	$_h = 0;

	$mw->secure( 0 );
	$get->();
	is "$sec!!$hto", '!!', 'Clearing both flags works';

	$_s = $_h = 1;
	$get->();
	is $hto, 'cx', '... and respects a pre-existing HttpOnly flag';
	is $sec, 'cx', '... as well as a pre-existing secure flag';
};
